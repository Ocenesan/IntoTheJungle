This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-11T00:56:49.475Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
BaseCharacter.h
BoundingBox.h
Bullet.h
Button.h
Cactus.h
Dino.h
DinoGameOverScreen.h
DinoGameScreen.h
DinoMainMenuScreen.h
DinoPauseScreen.h
Enemy.h
Game.h
Hero.h
InGameScreen.h
Input.h
ITJ.h
ITJGameOver.h
ITJGameScreen.h
ITJMainMenu.h
Launcher.h
Lesson01_BgColor.h
Lesson02_Lerp.h
Lesson03_Animation.h
Lesson04_Movement.h
Lesson05_Input.h
Lesson06_ObjectPool.h
Lesson07_GUI.h
Lesson08_Rotation.h
Lesson09_Bullet.h
Lesson10_Platform.h
Lesson11_ParallaxScrolling.h
LessonAI01_SteeringBehaviors.h
LessonAI02_NPCWave.h
MainMenuScreen.h
Music.h
Quad.h
SATCollision.h
Screen.h
ScreenManager.h
Setting.h
Shader.h
Sound.h
Sprite.h
Text.h
Texture.h
Turtle.h

================================================================
Repository Files
================================================================

================
File: BaseCharacter.h
================
#ifndef BASECHARACTER_H
#define BASECHARACTER_H

#include "Sprite.h"

namespace Engine {
	
	enum class CharacterState {
		ALIVE,
		DEAD
	};

	class BaseCharacter {
	public:
		BaseCharacter(Texture* texture, Shader* shader, Quad* quad);
		~BaseCharacter();
		void Update(float deltaTime);
		void Draw();
		void SetPosition(float x, float y);
		vec2 GetPosition();
		Sprite* GetSprite();
	protected:
		Sprite* sprite;
		CharacterState state;
		vec2 velocity;
	};
}
#endif

================
File: BoundingBox.h
================
#ifndef BOUNDINGBOX_H
#define BOUNDINGBOX_H

#include <GLM/glm.hpp>
#include <array>
#include "SATCollision.h"

using namespace glm;
using namespace std;
using RectVertexArray = array<vec2, 4>;

namespace Engine {
	class BoundingBox {
	public:
		bool CollideWith(BoundingBox* other);
		void SetVertices(vec2 p1, vec2 p2, vec2 p3, vec2 p4);
		RectVertexArray GetVertices();
		float width, height;
	private:
		RectVertexArray vertices;
	};
}

#endif

================
File: Bullet.h
================
#ifndef BULLET_H
#define BULLET_H

#include "Sprite.h"

namespace Engine {
	class Bullet
	{
	public:
		Bullet(Sprite* sprite);
		~Bullet();
		float xVelocity = 0;
		Sprite* sprite;
		void SetPosition(float x, float y);
		vec2 GetPosition();
		void Update(float deltaTime);
		void Draw();
	};
}
#endif

================
File: Button.h
================
#ifndef BUTTON_H
#define BUTTON_H

#include "Sprite.h"

namespace Engine {
	enum class ButtonState {
		PRESS,
		HOVER,
		NORMAL
	};
	class Button
	{
	public:
		Button(Sprite* sprite, string name);
		~Button();
		void Update(float deltaTime);
		void Draw();
		void SetPosition(float x, float y);
		vec2 GetPosition();
		ButtonState GetButtonState();
		void SetButtonState(ButtonState state);
		string GetButtonName();
	private:
		ButtonState state;
		Sprite* sprite;
		string name;
	};
}

#endif

================
File: Cactus.h
================
#ifndef CACTUS_H
#define CACTUS_H

#include "Sprite.h"

namespace Engine {
	enum class CactusState {
		SPAWN,
		GROUND,
		DIE
	};
	class Cactus
	{
	public:
		Cactus(Sprite* sprite);
		~Cactus();
		void Update(float deltaTime);
		void Draw();
		Cactus* SetPosition(float x, float y);
		Cactus* SetSpawn();
		float GetWidth();
		float GetHeight();
		bool IsDie();
		float GetX();
		float GetY();
		Sprite* GetSprite();
		Cactus* SetCactusState(CactusState state);
		float GetXVelocity() const;
		void SetXVelocity(float x);
	protected:
		Sprite* sprite = NULL;
		CactusState state;
		float groundDur = 0, groundTime = 0, x = 0, y = 0;
		float xVelocity = 0.2f;
	};

}

#endif

================
File: Dino.h
================
#ifndef DINO_H
#define DINO_H

#include "Game.h"
#include "Sound.h"
#include "Music.h"
#include "Setting.h"
#include "DinoMainMenuScreen.h"
#include "DinoGameScreen.h"
#include "DinoGameOverScreen.h"
#include "DinoPauseScreen.h"

namespace Engine {
	class Dino :public Engine::Game
	{
	public:
		Dino(Setting* setting);
		~Dino();
		virtual void Init();
		virtual void Update();
		virtual void Render();
		int GetScore() const;
		void SetScore(int x);
		int GetBestScore() const;
		void SetBestScore(int x);
		Music* music = NULL;
		Sound* sound = NULL;
	private:
		int score = 0;
		int bestScore = 0;
	};
}

#endif

================
File: DinoGameOverScreen.h
================
#ifndef DINOGAMEOVERSCREEN_H
#define DINOGAMEOVERSCREEN_H

#include "Screen.h"
#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Button.h"
#include "Text.h"
#include <vector>
#include "ScreenManager.h"
#include "Dino.h"

namespace Engine {
	class Dino;
	class DinoGameOverScreen :
		public Engine::Screen
	{
	public:
		DinoGameOverScreen(Dino* dinoInstance);
		void Init();
		void Update();
		void Draw();
		void SetBestScoreText();
	private:
		vector<Button*> buttons;
		Text* gameOverText = NULL;
		Text* bestScoreText = NULL;
		int currentButtonIndex = 0;
		Dino* dino;
	};
}

#endif

================
File: DinoGameScreen.h
================
#ifndef DINOGAMESCREEN_H
#define DINOGAMESCREEN_H

#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Cactus.h"
#include "Text.h"
#include <vector>
#include "Screen.h"
#include "ScreenManager.h"
#include "Dino.h"

namespace Engine {
	class Dino;
	class DinoGameScreen :
		public Engine::Screen
	{
	public:
		DinoGameScreen(Dino* dinoInstance);
		void Init();
		void Update();
		void Draw();
		void GameOver();
	private:
		Texture* texture = NULL;
		Sprite* sprite = NULL;
		float yVelocity = 0, gravity = 0;
		bool jump = false, debug = false;
		Texture* cactus_texture = NULL;
		Engine::Sprite* CreateCactusSprite();
		void SpawnCacti();
		void ScorePerDuration(float seconds);
		vector<Engine::Cactus*> cacti;
		float spawnCactusDuration = 0, maxCactusSpawnTime = 0, numCactusInPool = 0, numCactusPerSpawn = 0, scoreDuration = 0;
		Text* scoreText = NULL;
		Dino* dino;
		vector<Sprite*> backgrounds, middlegrounds, foregrounds;
		void MoveLayer(vector<Sprite*>& bg, float speed);
		void DrawLayer(vector<Sprite*>& bg);
		void AddToLayer(vector<Sprite*>& bg, string name);
		float offset = 0;
		bool paused = false;
		float speed = 0.2f;
		float speedIncrease = 0.1f;
	};
}

#endif

================
File: DinoMainMenuScreen.h
================
#ifndef DINOMAINMENUSCREEN_H
#define DINOMAINMENUSCREEN_H

#include "Screen.h"
#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Button.h"
#include "Text.h"
#include <vector>
#include "ScreenManager.h"

namespace Engine {
	class DinoMainMenuScreen :
		public Engine::Screen
	{
	public:
		DinoMainMenuScreen();
		void Init();
		void Update();
		void Draw();
	private:
		vector<Button*> buttons;
		Text* text;
		int currentButtonIndex = 0;
	};
}

#endif

================
File: DinoPauseScreen.h
================
#ifndef DINOPAUSESCREEN_H
#define DINOPAUSESCREEN_H

#include "Screen.h"
#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Button.h"
#include "Text.h"
#include <vector>
#include "ScreenManager.h"

namespace Engine {
	class DinoPauseScreen :
		public Engine::Screen
	{
	public:
		DinoPauseScreen();
		void Init();
		void Update();
		void Draw();
	private:
		vector<Button*> buttons;
		Text* text;
		int currentButtonIndex = 0;
	};
}

#endif

================
File: Enemy.h
================
#ifndef ENEMY_H
#define ENEMY_H

#include "Sprite.h"
#include "BaseCharacter.h"

namespace Engine {
	class Enemy:public Engine::BaseCharacter
	{
	public:
		Enemy(Texture* texture, Shader* shader, Quad* quad);
		~Enemy();
		void Update(float deltaTime);
		void SetTarget(BaseCharacter* target);
		void SetMaxSpeed(float maxSpeed);
		void Move(float deltaTime);
	private:
		vec2 Engine::Enemy::Seek();
		string Engine::Enemy::FacingSprite(vec2 position, vec2 target);
		BaseCharacter *target;
		float maxSpeed;
	};
}
#endif

================
File: Game.h
================
#ifndef BASEGAME_H
#define BASEGAME_H

#include <SDL/SDL.h>
#include <SDL/SDL_mixer.h>
#include <GL/glew.h>
#include <iostream>
#include "Setting.h"
#include "Shader.h"
#include "Quad.h"
#include "Input.h"
#include <map>
#include <GLM/gtc/matrix_transform.hpp>

using namespace std;

namespace Engine {
	enum class State {
		RUNNING,
		EXIT
	};

	class Game
	{
	public:
		Game(Setting* setting);
		~Game();
		void SetBackgroundColor(int r, int g, int b);
		void Run();
		mat4 GetDefaultProjection();
		Shader* GetDefaultSpriteShader();
		Shader* GetDefaultTextShader();
		Quad* GetDefaultQuad();
		Input* GetInputManager();
		Setting* GetSettings();
		float GetGameTime();
		State GetState();
		void SetState(State state);
	protected:
		Setting* setting = NULL;
		State state;
		unsigned int currentFrameRate = 0;
		mat4 defaultProjection;
		Shader* defaultSpriteShader = NULL;
		Shader* defaultTextShader = NULL;
		Quad* defaultQuad = NULL;
		Input* inputManager = NULL;
	
		mat4 CreateDefaultProjection();
		Shader* CreateDefaultSpriteShader();
		Shader* CreateDefaultTextShader();
		virtual void Init() = 0;
		virtual void Update() = 0;
		virtual void Render() = 0;

	private:
		mat4 projection;
		float targetFrameTime = 0;
		float deltaTime = 0;
		unsigned int lastTime = 0, duration = 0, numFrame = 0;
		SDL_Window* InitInternal();
		void GameLoop(SDL_Window* window);
		void CalcDeltaTimeAndFramerate();
		void PollInput();
	};
}

#endif

================
File: Hero.h
================
#include "Sprite.h"
#include "BaseCharacter.h"
#include "Input.h"

#ifndef HERO_H
#define HERO_H

namespace Engine {
	class Hero :public Engine::BaseCharacter
	{
	public:
		Hero(Texture* texture, Shader* shader, Quad* quad);
		~Hero();
		void Update(float deltaTime);
		void Move(float deltaTime);
		void Init(Input* inputManager);
	private:
		Input* inputManager;
	};
}
#endif

================
File: InGameScreen.h
================
#ifndef INGAMESCREEN_H
#define INGAMESCREEN_H

#include "Screen.h"
#include "Turtle.h"
#include "ScreenManager.h"

namespace Engine {
	class InGameScreen :
		public Engine::Screen
	{
	public:
		InGameScreen();
		void Init();
		void Update();
		void Draw();
	private:
		Engine::Sprite* CreateSprite(Texture* texture);
		void SpawnObjects();
		vector<Turtle*> objects;
		float spawnDuration = 0, maxSpawnTime = 0, numObjectsInPool = 0, numObjectPerSpawn = 0;
	};
}

#endif

================
File: Input.h
================
#ifndef INPUT_H
#define INPUT_H

#include <string>
#include <iostream>
#include <SDL/SDL.h>
#include <GLM/glm.hpp>
#include <GLM/gtc/matrix_transform.hpp>
#include <GLM/gtc/type_ptr.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <unordered_map>

using namespace std;
using namespace glm;

namespace Engine {
	class Input
	{
	public:
		bool IsKeyPressed(string name);
		bool IsKeyReleased(string name);
		vec2 GetMouseCoords();
		void PressKey(unsigned int keyID);
		void ReleaseKey(unsigned int keyID);
		void SetMouseCoords(float x, float y);
		void OpenGameController();
		void CloseGameController();
		Engine::Input* AddInputMapping(string mappingName, unsigned int keyId);
		void Reset();
	
	private:
		vec2 mouseCoords;
		SDL_GameController* controller;
		unordered_map<unsigned int, string> keyCodeNameMap;
		unordered_map<string, bool> pressedKeyMap;
		vector<string> releasedKeys;
	};
}

#endif

================
File: ITJ.h
================
#ifndef ITJ_H
#define ITJ_H

#include "Game.h"
#include "Sound.h"
#include "Music.h"
#include "Setting.h"
#include "ITJMainMenu.h"
#include "ITJGameScreen.h"
#include "ITJGameOver.h"

namespace Engine {
	class ITJ :public Engine::Game
	{
	public:
		ITJ(Setting* setting);
		~ITJ();
		virtual void Init();
		virtual void Update();
		virtual void Render();
		Music* music = NULL;
		Sound* sound = NULL;
	private:

	};
}

#endif

================
File: ITJGameOver.h
================
#ifndef ITJGAMEOVER_H
#define ITJGAMEOVER_H

#include "Screen.h"
#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Button.h"
#include "Text.h"
#include <vector>
#include "ScreenManager.h"
#include "ITJ.h"

namespace Engine {
	class ITJ;
	class ITJGameOver :
		public Engine::Screen
	{
	public:
		ITJGameOver(ITJ* itjInstance);
		void Init();
		void Update();
		void Draw();
	private:
		vector<Button*> buttons;
		Text* gameOverText = NULL;
		int currentButtonIndex = 0;
		ITJ* itj;
	};
}

#endif

================
File: ITJGameScreen.h
================
#ifndef ITJGAMESCREEN_H
#define ITJGAMESCREEN_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Music.h"
#include "Sound.h"
#include "Text.h"
#include <vector>
#include "Screen.h"
#include "ScreenManager.h"
#include "ITJ.h"

namespace Engine {
	class ITJ;
	class ITJGameScreen : public Screen
	{
	public:
		ITJGameScreen(ITJ* itjInstance);
		//~ITJGameScreen();
		void GenerateTileMap();
		void Init();
		void Update();
		void Draw();
	private:
		ITJ* itj;
		vector<Sprite*> platforms;
		vector<Sprite*> obstacles; // Rintangan pohon
		vector<Sprite*> treasureChests; // Peti harta
		vector<Sprite*> coins;     // Koin
		Sprite* npcSprite = NULL;  // NPC untuk menjual kunci
		Sprite* bjornSprite = NULL;
		Sprite* backgroundSprite = NULL;
		Sprite* treeSprite = NULL;
		Sprite* coin = NULL;
		Sprite* keySprite = NULL;
		Sprite* barSprite = NULL;
		Sprite* hearts = NULL;
		Music* music = NULL;;
		Sound* sound = NULL;
		Text* text = NULL;
		float yVelocity = 0, gravity = 0;
		bool jump = false, debug = false;
		bool hasKey = false; // Status apakah pemain punya kunci
		int playerHealth = 3;      // Nyawa Bjorn
		int coinCount = 0;         // Jumlah koin terkumpul
		bool isImmune = false; // Status kebal
		float immunityDuration = 2000.0f; // Durasi kebal dalam milidetik
		float immunityTimer = 0.0f; // Timer untuk menghitung sisa waktu kebal
		std::vector<std::vector<int>> tileMap; // 2D array map layout
		const int TILE_SIZE = 32; // Adjust based on sprites
	};
}
#endif

================
File: ITJMainMenu.h
================
#ifndef ITJMAINMENU_H
#define ITJMAINMENU_H

#include "Screen.h"
#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Button.h"
#include "Text.h"
#include <vector>
#include "ScreenManager.h"

namespace Engine {
	class ITJMainMenu :
		public Engine::Screen
	{
	public:
		ITJMainMenu();
		~ITJMainMenu();
		void Init();
		void Update();
		void Draw();
	private:
		vector<Button*> buttons;
		Text* text;
		Sprite* backgroundSprite = NULL;
		int currentButtonIndex = 0;
	};
}

#endif

================
File: Launcher.h
================


================
File: Lesson01_BgColor.h
================
#ifndef LESSON01_BGCOLOR_H
#define LESSON01_BGCOLOR_H

#include "Game.h"
#include "Setting.h"

namespace Engine {
	class Lesson01_BgColor :public Engine::Game
	{
	public:
		Lesson01_BgColor(Setting* setting);
		~Lesson01_BgColor();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		float color_duration;
		int r, g, b;
		int mul;
	};
}

#endif

================
File: Lesson02_Lerp.h
================
#ifndef LESSON02_LERP_H
#define LESSON02_LERP_H

#include "Game.h"
#include "Setting.h"

namespace Engine {
	class Lesson02_Lerp :public Engine::Game
	{
	public:
		Lesson02_Lerp(Setting* setting);
		~Lesson02_Lerp();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		float color_duration, f;
		int mul, r_y, g_y, b_y, r_p, g_p, b_p;
		int lerp(float a, float b, float f);
	};
}

#endif

================
File: Lesson03_Animation.h
================
#ifndef LESSON03_ANIMATION_H
#define LESSON03_ANIMATION_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"

namespace Engine {
	class Lesson03_Animation :public Engine::Game
	{
	public:
		Lesson03_Animation(Setting* setting);
		~Lesson03_Animation();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Engine::Texture* texture = NULL;
		Engine::Sprite* sprite = NULL;
	};
}

#endif

================
File: Lesson04_Movement.h
================
#ifndef LESSON04_MOVEMENT_H
#define LESSON04_MOVEMENT_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"

namespace Engine {
	class Lesson04_Movement :public Engine::Game
	{
	public:
		Lesson04_Movement(Setting* setting);
		~Lesson04_Movement();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Engine::Texture* texture = NULL;
		Engine::Sprite* sprite = NULL;
		float mul = 1;
	};
}

#endif

================
File: Lesson05_Input.h
================
#ifndef LESSON05_INPUT_H
#define LESSON05_INPUT_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"

namespace Engine {
	class Lesson05_Input :public Engine::Game
	{
	public:
		Lesson05_Input(Setting* setting);
		~Lesson05_Input();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Engine::Texture* texture = NULL;
		Engine::Sprite* sprite = NULL;
	};
}

#endif

================
File: Lesson06_ObjectPool.h
================
#ifndef LESSON06_OBJECTPOOL_H
#define LESSON06_OBJECTPOOL_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Turtle.h"
#include <vector>

namespace Engine {
	class Lesson06_ObjectPool :public Engine::Game
	{
	public:
		Lesson06_ObjectPool(Setting* setting);
		~Lesson06_ObjectPool();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Engine::Texture* texture = NULL;
		Engine::Sprite* CreateSprite();
		void SpawnObjects();
		vector<Engine::Turtle*> objects;
		float spawnDuration = 0, maxSpawnTime = 0, numObjectsInPool = 0, numObjectPerSpawn = 0;
	};
}

#endif

================
File: Lesson07_GUI.h
================
#ifndef Lesson07_GUI_H
#define Lesson07_GUI_H

#include "Game.h"
#include "Setting.h"
#include "MainMenuScreen.h"
#include "InGameScreen.h"

namespace Engine {
	class Lesson07_GUI :public Engine::Game
	{
	public:
		Lesson07_GUI(Setting* setting);
		~Lesson07_GUI();
		virtual void Init();
		virtual void Update();
		virtual void Render();	
	};
}

#endif

================
File: Lesson08_Rotation.h
================
#ifndef LESSON08_H
#define LESSON08_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"

namespace Engine {
	class Lesson08_Rotation :public Engine::Game
	{
	public:
		Lesson08_Rotation(Setting* setting);
		~Lesson08_Rotation();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Engine::Texture* texture = NULL;
		Engine::Sprite* sprite = NULL;
		float mul = 1, degree = 0;

	};
}

#endif

================
File: Lesson09_Bullet.h
================
#ifndef LESSON09_BULLET_H
#define LESSON09_BULLET_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Bullet.h"

namespace Engine {
	class Lesson09_Bullet :public Engine::Game
	{
	public:
		Lesson09_Bullet(Setting* setting);
		~Lesson09_Bullet();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Engine::Texture* texture = NULL, *bulletTexture = NULL;
		Engine::Sprite* sprite = NULL;
		vector<Bullet*> inUseBullets;
		vector<Bullet*> readyBullets;
		float yVelocity = 0, gravity = 0, timeInterval = 0, xBulletVel = 0;
		bool jump = false, toRight = true;
		void SpawnBullets();

	};
}

#endif

================
File: Lesson10_Platform.h
================
#ifndef LESSON10_PLATFORM_H
#define LESSON10_PLATFORM_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Music.h"
#include "Sound.h"
#include "Text.h"
#include <vector>

namespace Engine {
	class Lesson10_Platform :
		public Engine::Game
	{
	public:
		Lesson10_Platform(Setting* setting);
		~Lesson10_Platform();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Texture* dotTexture = NULL;
		vector<Sprite*> platforms;
		Sprite* monsterSprite = NULL;
		Sprite* backgroundSprite = NULL;
		Sprite* dotSprite1 = NULL;
		Sprite* dotSprite2 = NULL;
		Sprite* dotSprite3 = NULL;
		Sprite* dotSprite4 = NULL;
		Music* music = NULL;;
		Sound* sound = NULL;
		Text* text = NULL;
		float yVelocity = 0, gravity = 0;
		bool jump = false, debug = false;
	};
}
#endif

================
File: Lesson11_ParallaxScrolling.h
================
#ifndef LESSON11_PARALLAXSCROLLING_H
#define LESSON01_PARALLAXSCROLLING_H

#include "Game.h"
#include "Setting.h"
#include <vector>
#include "Sprite.h"

namespace Engine {
	class Lesson11_ParallaxScrolling :public Engine::Game
	{
	public:
		Lesson11_ParallaxScrolling(Setting* setting);
		~Lesson11_ParallaxScrolling();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		vector<Sprite*> backgrounds, middlegrounds, foregrounds;
		void MoveLayer(vector<Sprite*> &bg, float speed);
		void DrawLayer(vector<Sprite*> &bg);
		void AddToLayer(vector<Sprite*> &bg, string name);
		float offset = 0;
	};
}

#endif

================
File: LessonAI01_SteeringBehaviors.h
================
#ifndef LESSONAI01_STEERINGBEHAVIORS_H
#define LESSONAI01_STEERINGBEHAVIORS_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"

namespace Engine {
	class LessonAI01_SteeringBehaviors :public Engine::Game
	{
	public:
		LessonAI01_SteeringBehaviors(Setting* setting);
		~LessonAI01_SteeringBehaviors();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Texture* texture;
		Sprite* playerSprite, * botSprite;
		vec2 botVelocity, playerVelocity;
		string FacingSprite(vec2 position, vec2 target);
		void ControlPlayerSprite();
		void CreatePlayerSprite();
		void ControBotSprite();
		void CreateBotSprite();
		vec2 Seek(vec2 position, vec2 velocity, vec2 target, float maxSpeed);
		vec2 Flee(vec2 position, vec2 velocity, vec2 target, float maxSpeed);
		vec2 Arrival(vec2 position, vec2 target, vec2 botVelocity, float maxSpeed, float slowRadius);
		vec2 Pursue(vec2 position, vec2 velocity, vec2 targetPos, vec2 targetVel, float maxSpeed);
	};
}
#endif

================
File: LessonAI02_NPCWave.h
================
#ifndef LESSONAI02_NPCWAVE_H
#define LESSONAI02_NPCWAVE_H

#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Enemy.h"
#include "Hero.h"
#include <random> 

namespace Engine {
	class LessonAI02_NPCWave :public Engine::Game
	{
	public:
		LessonAI02_NPCWave(Setting* setting);
		~LessonAI02_NPCWave();
		virtual void Init();
		virtual void Update();
		virtual void Render();
	private:
		Texture* texture;
		float spawnTimer;
		vector<Enemy*> enemies;
		Hero* hero;
	};
}
#endif

================
File: MainMenuScreen.h
================
#ifndef MAINMENUSCREEN_H
#define MAINMENUSCREEN_H

#include "Screen.h"
#include "Game.h"
#include "Setting.h"
#include "Texture.h"
#include "Sprite.h"
#include "Button.h"
#include "Text.h"
#include <vector>
#include "ScreenManager.h"

namespace Engine {
	class MainMenuScreen :
		public Engine::Screen
	{
	public:
		MainMenuScreen();
		void Init();
		void Update();
		void Draw();
	private:
		vector<Button*> buttons;
		Text* text;
		int currentButtonIndex = 0;
	};
}

#endif

================
File: Music.h
================
#ifndef MUSIC_H
#define MUSIC_H

#include <SDL/SDL_mixer.h>


namespace Engine {
	class Music
	{
	public:
		Music(const char* path);
		~Music();
		bool IsPaused();
		bool IsPlaying();
		Music* Play(bool loop);
		Music* Pause();
		Music* Resume();
		Music* Stop();
		Music* SetVolume(int volume);
	private:
		Mix_Music* music = NULL;
		int volume = 100;
	};
}

#endif

================
File: Quad.h
================
#ifndef QUAD_H
#define QUAD_H

#include <SDL/SDL.h>
#include <GL/glew.h>


namespace Engine {
	class Quad
	{
	public:
		Quad();
		~Quad();
		void Draw();
	private:
		GLuint vbo, ebo, vao;
		void Build();
	};
}

#endif

================
File: SATCollision.h
================
#ifndef SATCOLLISION_H
#define SATCOLLISION_H

#include <GLM/glm.hpp>
#include <array>
#include <limits>

using namespace glm;
using namespace std;
static const float NORMAL_TOLERANCE = 0.0001f;
using RectVertexArray = array<vec2, 4>;

namespace Engine {
	struct Result {
		float min_proj, max_proj, min_index, max_index;
	};
	class SATCollision
	{
	public:
		static bool CheckCollision(RectVertexArray& vecs_box1, RectVertexArray& vecs_box2);
	private:
		static Result getMinMax(RectVertexArray& vecs_box, vec2& axis);
		static RectVertexArray GetNormals(RectVertexArray& dots);
		static vec2 GetNormal(const vec2& v);
		static float dotProduct(const vec2& a, const vec2& b);
	};

}
#endif

================
File: Screen.h
================
#ifndef SCREEN_H
#define SCREEN_H

#include "Game.h"

namespace Engine {
	class Screen
	{
	public:
		virtual void Init()=0;
		virtual void Update()=0;
		virtual void Draw()=0;
		void SetGame(Game* engine);
	protected:
		Game* game = nullptr;
	};
}
#endif

================
File: ScreenManager.h
================
#ifndef SCREENMANAGER_H
#define SCREENMANAGER_H

#include "Game.h"
#include "Screen.h"
#include <unordered_map>

namespace Engine {
	class ScreenManager
	{
	public:
		ScreenManager(const ScreenManager& obj) = delete;
		static Engine::ScreenManager* GetInstance(Game* engine);
		void Update();
		void Draw();
		ScreenManager* AddScreen(string name, Screen* screen);
		ScreenManager* SetCurrentScreen(string name);
		Screen* GetCurrentScreen();
		Game* GetGame();
	    ScreenManager* SetGame(Game* engine);
		Screen* GetScreen(string name);
	private:
		ScreenManager();
		unordered_map<string, Screen*> screens;
		Game* engine;
		Screen* currentScreen;
		static Engine::ScreenManager* instance;
	};
}

#endif

================
File: Setting.h
================
#ifndef SETTING_H
#define SETTING_H

#include <string>

using namespace std;

namespace Engine {
	enum class WindowFlag {
		WINDOWED,
		FULLSCREEN,
		EXCLUSIVE_FULLSCREEN,
		BORDERLESS
	};

	class Setting
	{
	public:
		Setting();
		~Setting();
		string windowTitle;
		int screenWidth, screenHeight, targetFrameRate;
		bool vsync;
		WindowFlag windowFlag;
		float timeScale;
	};
}

#endif

================
File: Shader.h
================
#ifndef SHADER_H
#define SHADER_H

#include <SDL/SDL.h>
#include <GL/glew.h>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <GLM/detail/type_mat.hpp>
#include <GLM/gtc/type_ptr.hpp>

using namespace std;
using namespace glm;

namespace Engine {
	class Shader
	{
	public:
		Shader(string vertex_path, string fragment_path);
		~Shader();
		Shader* Build();
		Shader* Use();
		GLuint GetId();
		Shader* setInt(int i, string str);
		Shader* setFloat(float i, string str);
		Shader* setMat4(mat4 mat, string str);
		Shader* setVec3(vec3 data, string str);
		
	private:
		string vertexPath, fragmentPath;
		GLuint programId;
		void Validate(GLuint shader_id, string type);
	};
}

#endif

================
File: Sound.h
================
#ifndef SOUND_H
#define SOUND_H

#include <SDL/SDL_mixer.h>


namespace Engine {
	class Sound
	{
	public:
		Sound(const char* path);
		~Sound();
		bool IsPlaying();
		Sound* Play(bool loop);
		Sound* SetVolume(int volume);
	private:
		Mix_Chunk* sound = NULL;
		int volume = 100;
	};

}

#endif

================
File: Sprite.h
================
#ifndef SPRITE_H
#define SPRITE_H

#include <vector>
#include "Shader.h"
#include "Texture.h"
#include "Quad.h"
#include "BoundingBox.h"
#include <GLM/gtc/matrix_transform.hpp>

using namespace glm;

namespace Engine {
	struct AnimData {
		string name;
		int startFrameIndex, endFrameIndex;
	};

	class Sprite
	{
	public:
		Sprite(Texture* texture, Shader* shader, Quad* quad);
		~Sprite();
		void Draw();
		void Update(float deltaTime);
		Sprite* AddAnimation(string name, int startFrameIndex, int endFrameIndex);
		Sprite* PlayAnim(string name);
		Sprite* SetFlipHorizontal(bool flipHorizontal);
		Sprite* SetFlipVertical(bool flipVertical);
		Sprite* SetAnimationDuration(float maxFrameDuration);
		Sprite* SetEnableAnimation(bool enableAnimation);
		Sprite* SetPosition(float x, float y);
		Sprite* SetRotation(float degree);
		Sprite* SetNumXFrames(int numXFrames);
		Sprite* SetNumYFrames(int numYFrames);
		Sprite* SetSize(float width, float height);
		Sprite* SetScale(float s);
		Sprite* SetBoundingBoxSize(float w, float h);
		Sprite* SetWireframe(bool wireframe);
		int GetTotalFrames();
		float GetRotation();
		float GetScale();
		float GetScaleWidth();
		float GetScaleHeight();
		BoundingBox* GetBoundingBox();
		vec2 GetPosition();
		vec2 GetRotatedPoint(float x, float y);
	private:
		BoundingBox* boundingBox;
		vec4 min;
		Shader* shader;
		Quad* quad;
		Texture* texture;
		float width = 0, height = 0, s = 1, degree = 0, frameDuration = 0, maxFrameDuration = 80;
		bool flipHorizontal = false, flipVertical = false, enableAnimation = false, wireframe = false;
		int numXFrames = 1, numYFrames = 1, frameIndex = 0;
		mat4 CreateTransform();
		void UpdateShaderData();
		AnimData* GetAnimData(string name);
		vec2 position;
		vector<AnimData*> animationData;
		AnimData* currentAnim = NULL;
		
	};
}

#endif

================
File: Text.h
================
#ifndef TEXT_H
#define TEXT_H

#include <ft2build.h>
#include <freetype/freetype.h>
#include <map>
#include <iostream>
#include <GL/glew.h>
#include <GLM/glm.hpp>
#include <GLM/gtc/type_ptr.hpp>
#include "Shader.h"

using namespace glm;
using namespace std;

namespace Engine {
	struct TextCharacter {
		GLuint TextureID; // ID handle of the glyph texture
		ivec2 Size; // Size of glyph
		ivec2 Bearing; // Offset from baseline to left/top of glyph
		GLuint Advance; // Offset to advance to next glyph
	};

	class Text
	{
	public:
		Text(const char* fontName, uint fontSize, Shader* shader);
		Text* SetScale(float scale);
		Text* SetColor(float r, float g, float b);
		Text* SetPosition(float x, float y);
		Text* SetText(string text);
		void Draw();
		uint GetFontSize();
		float GetScale();
	private:
		void Init();
		map<GLchar, TextCharacter> TextCharacters;
		uint fontSize = 12;
		const char* fontName = NULL;
		GLuint vbo, ebo, vao;
		Shader* shader;
		vec3 color = vec3(1.0f, 1.0f, 1.0f);
		float scale = 1.0f;
		vec2 position = vec2(0, 0);
		string text = "";
	};

}

#endif

================
File: Texture.h
================
#ifndef TEXTURE_H
#define TEXTURE_H

#include <iostream>
#include <SOIL/SOIL.h>
#include <SDL/SDL.h>
#include <GL/glew.h>

using namespace std;

namespace Engine {
	class Texture
	{
	public:
		Texture(string imagePath);
		~Texture();
		GLuint GetTextureId();
		int GetWidth();
		int GetHeight();
		void Bind();
		void UnBind();
		void SetSmooth(bool smooth);
	private:
		GLuint textureId;
		int width, height;
		void Load(string imagePath);

	};
}

#endif

================
File: Turtle.h
================
#ifndef TURTLE_H
#define TURTLE_H

#include "Sprite.h"

namespace Engine {
	enum class TurtleState {
		SPAWN,
		GROUND,
		DIE
	};
	class Turtle
	{
	public:
		Turtle(Sprite* sprite);
		~Turtle();
		void Update(float deltaTime);
		void Draw();
		Turtle* SetPosition(float x, float y);
		Turtle* SetSpawn();
		float GetWidth();
		float GetHeight();
		bool IsDie();
		float GetX();
		float GetY();
	protected:
		Sprite* sprite = NULL;
		TurtleState state;
		float groundDur = 0, groundTime = 0, x = 0, y = 0;
	};

}

#endif
